(define (timed-prime-test n) 
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (fast-prime? n 10000)
      (report-prime n (- (runtime) start-time))))
(define (report-prime n elapsed-time)
  (newline)
  (display n)
  (display " *** ")
  (display elapsed-time))

(define (search-for-primes start end)
  (cond ((< start end)
     (timed-prime-test start)
     (search-for-primes (+ start (if (even? start) 1 2)) end)
  ))
)

(define (expmod base ex m)
  (cond ((= ex 0) 1)
        ((even? ex)
         (remainder (square (expmod base (/ ex 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- ex 1) m))
                    m))))

(define (expmod2 base ex m)
    (remainder (fast-expt base ex) m))

(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(define (fast-prime? n times)
  (define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (fast-prime2? n times)
  (define (fermat-test n)
  (define (try-it a)
    (= (expmod2 a n n) a))
  (try-it (+ 1 (random (- n 1)))))
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(newline)
(display " *** 10^12 ")
;(search-for-primes (expt 10 12) (+ (expt 10 12) 100))
(newline)
(display " *** 10^15 ")
;(search-for-primes (expt 10 15) (+ (expt 10 15) 100))
(newline)
(display " *** 10^18 ")
;(search-for-primes (expt 10 18) (+ (expt 10 18) 100))

; fast-prime? & fast-prime2? are functionally equivalent
; however fast-prime? is much more efficient.
; 
; I used substitution to compare the processes generated by (expmod 2 10 3)
; and (expmod2 2 10 3).
; (e1 2 10 3)
; (r (sq (e1 2 5 3)) 3)
; (r (sq (r (* 2 (e1 2 4 3)...
; (r (sq (r (* 2 (r (sq (e1 2 2 3)...
; (r (sq (r (* 2 (r (sq (r (sq (e1 2 1 3)...
; (r (sq (r (* 2 (r (sq (r (sq (r (* 2 (e1 2 0 3)...
; (r (sq (r (* 2 (r (sq (r (sq (r 2 3)...
; (r (sq (r (* 2 (r (sq (r 4 3)...
; (r (sq (r (* 2 (r 1 3)...
; (r (sq (r 2 3)...
; (r 4 3)
; 1
;
;(e2 2 10 3)
;(r (fe 2 10) 3)
;(fe 2 10)
;(sq (fe 2 5))
;(sq (* 2 (fe 2 4)))
;(sq (* 2 (sq (fe (2 2)...
;(sq (* 2 (sq (sq (fe 2 1)...
;(sq (* 2 (sq (sq (* 2 (fe 2 0)...
;(sq (* 2 (sq (sq 2)...
;(sq (* 2 (sq 4)...
;(sq (* 2 16))
;(sq 32)
;(r 1024 3)
;1

; I could see that they both used the same number of steps and this left me
; perplexed. I thought about it some more and started to suspect that the
; difference had to do with the size of the numbers, but for some reason
; I couldn't come up with an explanation of why this would matter.
;
; Looking for the solution online confirmed my initial suspision it IS the
; size of the numbers. This makes sense because the processor can't fit
; numbers > 32-bit in it's registers, so the * function must take a different
; path for numbers > 32-bit, and this path causes the processor to execute
; many more steps. Is this right?



